# Упражнение 91. Григорианский календарь в порядковый
# (72 строки)
# Порядковая дата содержит номер года и порядковый номер дня в этом
# году – оба в целочисленном формате. При этом год может быть любым
# согласно григорианскому календарю, а номер дня – числом в интервале
# от 1 до 366 (чтобы учесть високосные годы). Порядковые даты удобно
# использовать при расчете разницы в днях, когда счет ведется именно
# в днях, а не месяцах. Например, это может касаться 90-дневного периода
# возврата товара для покупателей, расчета срока годности товаров или
# прогнозируемой даты появления малыша на свет.
# Напишите функцию с именем ordinalDate, принимающую на вход три
# целых числа: день, месяц и год. Функция должна возвращать порядковый
# номер заданного дня в указанном году. В основной программе у пользо-
# вателя должны запрашиваться день, месяц и год соответственно и выво-
# диться на экран порядковый номер дня в заданном году. Программа долж-
# на запускаться только в том случае, если она не импортирована в виде
# модуля в другой файл.

# Упражнение 92. Порядковая дата в григорианский
# календарь
# (103 строки)
# Разработайте функцию, принимающую в качестве единственного па-
# раметра порядковую дату, включающую в себя год и день по порядку.
# В качестве результата функция должна возвращать день и месяц, соот-
# ветствующие переданной порядковой дате. Убедитесь, что ваша функция
# корректно обрабатывает високосные годы.
# Используйте эту функцию, а также функцию ordinalDate, написанную
# при выполнении упражнения 91, для разработки основной программы.
# Для начала должен производиться запрос порядковой даты у пользова-
# теля. После этого программа должна вычислить вторую дату, отстоящую
# от первой на определенное количество дней. Например, ваша программа
# могла бы запрашивать у пользователя порядковую дату, когда был при-
# обретен товар, и выводить последнюю дату, когда можно осуществить
# возврат (согласно определенным правилам возврата товаров). Или вы
# могли бы спрогнозировать дату появления ребенка на свет на основании
# срока беременности в 280 дней. Удостоверьтесь, что программа корректно
# обрабатывает ситуации, когда заданная дата и расчетная находятся
# в разных годах.


def is_leap_year(year: int) -> bool:
    """
    год, номер которого кратен 400, — високосный
    остальные годы, номер которых кратен 100, — невисокосные (например, годы 1700, 1800, 1900, 2100, 2200, 2300)
    остальные годы, номер которых кратен 4, — високосные
    все остальные годы — невисокосные
    """
    return year % 400 == 0 or year % 4 == 0 and year % 100 != 0

def ordinal_date(day: int, month: int, year: int) -> int:
    days_per_month = {1: 31, 2: 28 + is_leap_year(year), 3: 31, 4: 30, 5: 31, 6: 30, 7: 31, 8: 31, 9: 30, 10: 31, 11: 30, 12: 31}
    for m in range(1, month):
        day += days_per_month[m]
    return day

def reverse_ordinal_date (years_days: str):
    year = int(years_days.split()[0])
    days = int(years_days.split()[1])
    days_per_month = {1: 31, 2: 28 + is_leap_year(year), 3: 31, 4: 30, 5: 31, 6: 30, 7: 31, 8: 31, 9: 30, 10: 31, 11: 30, 12: 31}
    amount_days_in_year = sum(days_per_month.values())
    while days > amount_days_in_year:
        days = days - amount_days_in_year
        year = year + 1
        days_per_month = {1: 31, 2: 28 + is_leap_year(year), 3: 31, 4: 30, 5: 31, 6: 30, 7: 31, 8: 31, 9: 30, 10: 31, 11: 30, 12: 31}
        amount_days_in_year = sum(days_per_month.values())
    for month in days_per_month:
        check_day = days - days_per_month[month]
        if check_day > 0:
            days = check_day
        else:
            break
    return f"{days} {month} {year}"

start_date = input("date = (d m y) ")
day_amount = int(input("amount of days = "))
day = int(start_date.split()[0])
month = int(start_date.split()[1])
year = int(start_date.split()[2])

ordinal_day_numper = ordinal_date(day,month,year)
print("end date is", reverse_ordinal_date(str(year) + " " + str(day_amount + ordinal_day_numper)))

#1367
